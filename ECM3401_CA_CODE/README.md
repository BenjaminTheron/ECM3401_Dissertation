# ECM3428_Edmonds_Karp

## Introduction
The intention of this project is to apply and evaluate the success of an evolutionary
algorithm for automatically designing quantum-gate circuits.

## Prerequisites and Installation
Before executing any of the pip installation commands, you must download/ update pip
via the following command: python -m pip install -U pip .

There are a number of resources used by this project with the installation process for
each being listed below:

    - Jupyter Notebook: If using Visual Studio Code, installing the Jupyter extension will
    suffice for using the Notebook files used in this project. Otherwise, execute the following
    command in the terminal: pip install notebook .

    - Qiskit: This is the core of the project and is used for facilitating the creation
    of quantum software, this can be installed by entering the following commands in the terminal:

        - pip install qiskit

        - pip install qiskit-ibm-runtime

    - Deap: This is used for the core functionality of the evolutionary algorithm and used
    for statistics tracking. To download Deap, enter the following command into the terminal:
    pip install deap .

    - Matplotlib: This is used for displaying the statistics generated by a run of the
    evolutionary algorithm and can be installed by entering the following command into the
    terminal: python -m pip install -U matplotlib .

    - Numpy: This is used to represent the circuit matrices and can be installed by entering
    the following command into the terminal: pip install numpy .

    - The Python math and random modules are also used in this project but are included in
    the Python standard libraries, so no installations other than Python (this can be done 
    here: https://www.python.org/downloads/) are required to successfully use them.

## Project Tutorial
This project was developed in Visual Studio Code, so the instructions provided below will
be relative to what is available/ used there.

This project does not use a complex file structure, and as Jupyter Notebook is used, everything
is run in-line instead of via the terminal. After installing the pre-requisite libraries and
the main program code, simply navigate to the main.ipynb file, choose the relevant kernel in the
top right and hit run all. After a few minutes the results of the program (the best circuit size
and fitness found, along with graphs showing the performance of the evolutionary algorithm over 
throughout the whole evolution) will appear at the bottom of the file.

There is a little more effort required to alter the circuit the evolutionary algorithm executes,
to do this follow the steps below (for each of the steps below, ctrl-f or command-f can be used to 
find precisely where these locations are):

    - Navigate to where the CIRCUIT_TYPE variable is initialised (just after where the functions are
    defined).

    - Declaring this constant as "grover" will execute grover circuits, with "qft" executing qft
    circuits.

    - Next specify the gate set and set of possible gates to be used. This is done by altering the
    goal_circuit and gate_set variables in the respective if statement (the gate set and set of 
    possible gates can be found in the corresponding circuit synthesis file, grover_circuits.py or
    qft_circuits.py).

    - The goal_circuit variable at the end of this if statement must also be altered to the corresponding
    circuit being used.

    - If the number of qubits being used by the circuits is also different, the following steps must
    be executed:

        - On the line where the evaluation function is registered with the deap toolbox, alter the num_qubits
        variable accordingly, this line can be found by ctrl-f or command-f and entering the following
        line: toolbox.register("evaluate", circuit_fitness, gate_set=gate_set, target_matrix=goal_matrix, num_qubits=

        - Next for any time the fitness function is called (should be twice in the main() function), you
        must alter the num_qubits parameter (this is the last one provided to the function) to the
        corresponding size. This line can be found by ctrl-f or command-f and entering the following
        line: circuit_fitness(circuit, gate_set, goal_matrix,.

        - Finally, to ensure that a diagram displaying the correct number of qubits in the circuit is
        displayed, find the following line and specify the number of qubits accordingly, here this is
        the second parameter. ctrl-f or command-f: best_circuit = convert_circuit(best_solution[1], 
   

To use this EA to evolve different quantum algorithms, simply configure a quantum circuit synthesis file
with the same structure and variables as is done with qft_circuits.py and grover_circuits.py and import
it in main.ipynb.

To add more circuits for the QFT or Grover problems, you need to add a corresponding gate set with the
same representation found in either of the synthesis files and a set of possible gates (a gate set in the 
circuit representation used by this project). Then create the circuits as was done with the others in the
file and decompose the circuit accordingly so that it can be imported and used correctly in the main.ipynb
file.

To alter the parameters used by the evolutionary algorithm, simply alter the corresponding variables
which can be found at the start of the main() function.

To alter the experiments used by this project, simply navigate to the experiment file corresponding to the
parameter experiment you wish to run. Here altering the range of the for loop (found in the last cell of 
the file) alters the amount of times the evolutionary algorithm is run for each parameter value that is 
evaluated, and the increment at the bottom of the file alters how many parameter values are altered. Akin
to the main program, simply choosing the desired kernel in the top right and hitting run all will execute
the experiment. The results of the experiments are written to the corresponding file in the experiment
results directory in csv format.

## Testing
Unit tests for each of the proprietary functions created in this project were carried out using the
unittest module (this is included in the Python standard library, so no installation is required).
These functions are:
    - circuit_fitness().
    - circuit_size().
    - convert_circuit().
    - crossover().
    - mutate().
    - random_gate().

Each of the tests are include in the tests directory, to execute each of these tests individually
simply run the following command via the terminal:

    - python3 <unit_test_name>.py

To execute each of the unit tests simultaneously via the test suite file, run the following command
via the terminal:

    - python3 test_suite.py

### Developer Documentation

Any and all documentation about the structure, design and implementation of this project can be found
in the REPORT.pdf and the PRESENTATION.pdf files in the docs directory.

### Notes
There are a number of further ways in which this project can be extended:

    - To investigate the use of sub-systems to generate, as linear combinations of the gate set, useful single qubit gates to facilitate the approximation of circuits for bigger problems.

    - To extend the EA in this paper (or any algorithm for automatically designing quantum circuits) to n-qubit problems. This would enable the EA to learn quantum algorithms outside of hard-coded circuits and become generally practical.

    - Introduce external noise into the circuit as a way to reduce the number of redundant gates
    appearing in circuits produced by the EA.

    - Utilise a more sophisticated multi-objective EA, and to fix the implementation of the current multi-
    objective EA such that it is able to successfully optimise against circuit size and circuit fitness.

    - Utilise a more sophisticated fitness function such as Mean Square Fidelity, which tracks the phase of
    a given circuit and uses a more practical formula (as opposed to just absolute different).

    - Naturally extending the EA and parameter experiments used in this project.

## Details

#### Authors
Benjamin Theron

#### License
MIT License